{"version":3,"file":"conveyer.min.js","sources":["../src/browser.ts","../src/utils.ts","../src/Conveyer.ts","../src/index.umd.ts","../src/consts.ts","../src/reactive.ts"],"sourcesContent":["/**\n * egjs-conveyer\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nexport const IS_IE = /msie|trident/g.test(\n  (typeof window !== \"undefined\" && window?.navigator?.userAgent?.toLowerCase()) || \"\",\n);\n","/**\n * egjs-conveyer\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nexport function isString(val: any): val is string {\n  return typeof val === \"string\";\n}\n\nexport function findIndex<T>(arr: T[], callback: (element: T, index: number) => boolean) {\n  const length = arr.length;\n\n  for (let i = 0; i < length; ++i) {\n    if (callback(arr[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n\nexport function instanceOfElement(el: any): el is Element {\n  return el instanceof Element || el instanceof Node;\n}\n\n\nexport function isIntersection(\n  pos1: number,\n  pos2: number,\n  target: \"start\" | \"end\",\n  intersection?: boolean | number,\n) {\n  if (!intersection) {\n    return false;\n  }\n  const intersectionRatio = intersection === true ? 1 : intersection;\n  const size = intersectionRatio * Math.abs(pos2 - pos1);\n\n  if (target === \"end\") {\n    // pos1 위치를 고정하고 pos2를 pos1 + size으로 보정\n    // Fix the position pos1 and adjust pos2 to pos1 + size\n    return pos1 < 0 && pos1 + size > 0;\n  }\n\n  // pos2 위치를 고정하고 pos1를 pos2 - size으로 보정\n  // Fix the position pos2 and adjust pos1 to pos2 - size\n  return pos2 - size < 0 && pos2 > 0;\n}\n","/**\n * egjs-conveyer\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport Axes, { OnChange, OnHold, PanInput, WheelInput } from \"@egjs/axes\";\nimport Component from \"@egjs/component\";\nimport { diff } from \"@egjs/children-differ\";\nimport { IS_IE } from \"./browser\";\nimport { ReactiveSubscribe, Reactive, Ref } from \"@cfcs/core\";\nimport {\n  ConveyerEvents, ConveyerItem,\n  ConveyerOptions, FindItemOptions, ConveyerReactiveState,\n  ScrollIntoViewOptions,\n} from \"./types\";\nimport { instanceOfElement, isIntersection, isString } from \"./utils\";\n\n\n/**\n * Conveyer adds Drag gestures to your Native Scroll.\n * @ko Conveyer는 네이티브 스크롤에 드래그 제스처를 추가합니다.\n * @extends Component\n * @support {\"ie\": \"9+(with polyfill)\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @example\n```html\n<div class=\"items\">\n  <div class=\"item\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item\"></div>\n</div>\n<script>\nimport Conveyer from \"@egjs/conveyer\";\n\nconst conveyer = new Conveyer(\".items\");\n</script>\n```\n */\n@ReactiveSubscribe\nclass Conveyer extends Component<ConveyerEvents> {\n  protected _scrollAreaElement: HTMLElement;\n  protected _axes: Axes | null = null;\n  protected _items: ConveyerItem[] = [];\n  protected _size = 0;\n  protected _scrollSize = 0;\n  protected _options: ConveyerOptions;\n  protected _animateParam: {\n    expectedPos: number;\n    offset: number;\n  } | null = null;\n\n  private _resizeObserver: ResizeObserver | null = null;\n  private _scrollTimer = 0;\n  private _isWheelScroll = false;\n  private _isDragScroll = false;\n  private _isAnimationScroll = false;\n  private _scrollArea: string | HTMLElement | Ref<HTMLElement>;\n\n  private _panInput: PanInput | null = null;\n  private _wheelInput: WheelInput | null = null;\n\n  /**\n   * Whether the scroll has reached the start.\n   * @ko 스크롤이 시작에 닿았는지 여부.\n   * @name Conveyer#isReachStart\n   * @type {boolean}\n   * @default true\n   * @readonly\n   * @example\n   * ```js\n   * import { Conveyer } from \"@egjs/conveyer\";\n   *\n   * const conveyer = new Conveyer(\".container\");\n   *\n   * conveyer.isReachStart\n   * ```\n   */\n  @Reactive(\"isReachStart\") private _isReachStart = true;\n  /**\n   * Whether the scroll has reached the end.\n   * @ko 스크롤이 끝에 닿았는지 여부.\n   * @name Conveyer#isReachEnd\n   * @type {boolean}\n   * @default false\n   * @readonly\n   * @example\n   * ```js\n   * import { Conveyer } from \"@egjs/conveyer\";\n   *\n   * const conveyer = new Conveyer(\".container\");\n   *\n   * conveyer.isReachEnd\n   * ```\n   */\n  @Reactive(\"isReachEnd\") private _isReachEnd = false;\n  /**\n   * the scroll position of the container\n   * @ko 컨테이너의 스크롤 위치\n   * @name Conveyer#scrollPos\n   * @type {number}\n   * @default 0\n   * @readonly\n   * @example\n   * ```js\n   * import { Conveyer } from \"@egjs/conveyer\";\n   *\n   * const conveyer = new Conveyer(\".container\");\n   *\n   * conveyer.scrollPos\n   * ```\n   */\n  @Reactive(\"scrollPos\") protected _pos = 0;\n  /**\n   * @param - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n   * @param - The option object of the InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 옵션 객체</ko>\n   */\n  constructor(scrollArea: string | HTMLElement | Ref<HTMLElement>, options: ConveyerOptions = {}) {\n    super();\n    this._options = {\n      horizontal: true,\n      useDrag: true,\n      useSideWheel: false,\n      autoInit: true,\n      boundaryMargin: 0,\n      scrollDebounce: 100,\n      useResizeObserver: false,\n      ...options,\n    };\n\n    this._scrollArea = scrollArea;\n    if (this._options.autoInit) {\n      this.init();\n    }\n  }\n  /**\n   * Finds an element for that direction.\n   * @ko 해당 방향에 대해 엘리먼트를 찾는다.]\n   * @see {@link /docs/examples/Methods direction's example} page for detailed information\n   * @param - direction of the element. \"start\" and \"end\" find inside. \"prev\" and \"next\" find outside. <ko>엘리먼트의 방향. \"start\", \"end\"는 안쪽으로 찾는다. \"prev\", \"next\"는 바깥쪽으로 찾는다.</ko>\n   * @param - Options for the `findElement` method. <ko>findElement 메서드의 옵션</ko>\n   * @example\n   * <p align=\"center\">\n   *  <img src=\"https://naver.github.io/egjs-conveyer/img/scrollIntoView1.png\" height=\"200\" />\n   * </p>\n   * <p align=\"center\">\n   *   <img src=\"https://naver.github.io/egjs-conveyer/img/scrollIntoView2.png\" height=\"210\" />\n   * </p>\n   */\n  public findElement(direction: \"start\" | \"end\" | \"prev\" | \"next\", options: FindItemOptions = {}) {\n    return this.findItem(direction, options)?.element || null;\n  }\n  /**\n   * Finds an item for an element or its direction.\n   * @ko 엘리먼트 또는 해당 방향에 대해 아이템을 찾는다.\n   * @see {@link /docs/examples/Methods direction's example} page for detailed information\n   * @param - direction of the element. \"start\" and \"end\" find inside. \"prev\" and \"next\" find outside. <ko>엘리먼트의 방향. \"start\", \"end\"는 안쪽으로 찾는다. \"prev\", \"next\"는 바깥쪽으로 찾는다.</ko>\n   * @param - Options for the `findItem` method. <ko>`findItem` 메서드의 옵션</ko>\n   * @example\n   * <p align=\"center\">\n   *  <img src=\"https://naver.github.io/egjs-conveyer/img/scrollIntoView1.png\" height=\"200\" />\n   * </p>\n   * <p align=\"center\">\n   *   <img src=\"https://naver.github.io/egjs-conveyer/img/scrollIntoView2.png\" height=\"210\" />\n   * </p>\n   */\n  public findItem(\n    target: HTMLElement | \"start\" | \"end\" | \"prev\" | \"next\",\n    options: FindItemOptions = {},\n  ): ConveyerItem | null {\n    const pos = this._pos;\n    const scrollSize = this._scrollSize;\n    const size = this._size;\n    const hitTest = options?.hitTest ?? 1;\n    const items = [...this._items];\n    const length = items.length;\n    const endPos = pos + size;\n    const sibling = options.sibling;\n    const intersection = options.intersection;\n    const startVirtualItem = { pos: 0, size: 0 };\n    const endVirtualItem = { pos: scrollSize, size: 0 };\n\n    if (items[0].pos > 0) {\n      items.unshift(startVirtualItem);\n    }\n    if (length && items[length - 1].pos + items[length - 1].size < scrollSize) {\n      items.push(endVirtualItem);\n    }\n    let selectedItem: ConveyerItem | undefined;\n\n\n    if (target === \"start\") {\n      if (pos < 0) {\n        return null;\n      }\n      const selectedItems = items.filter(item => {\n        const itemSize = item.size;\n        const dist = item.pos - pos;\n        const dist2 = dist + itemSize;\n\n        return (dist >= 0)\n          || (dist2 > 0 && isIntersection(dist, dist2, \"end\", intersection))\n          || (dist2 >= 0 && (!itemSize || Math.abs(dist2) / itemSize >= hitTest));\n      });\n\n      selectedItem = (selectedItems[0] === startVirtualItem && selectedItems[1]) || selectedItems[0];\n    } else if (target === \"end\") {\n      if (pos > scrollSize - size) {\n        return null;\n      }\n      const selectedItems = items.filter(item => {\n        const itemSize = item.size;\n        const dist = item.pos + itemSize - endPos;\n        const dist2 = dist - itemSize;\n\n        return dist <= 0\n          || (dist2 < 0 && isIntersection(dist2, dist, \"start\", intersection))\n          || (dist2 <= 0 && (!itemSize || Math.abs(dist2) / itemSize >= hitTest));\n      }).reverse();\n\n      selectedItem = (selectedItems[0] === endVirtualItem && selectedItems[1]) || selectedItems[0];\n    } else if (target === \"prev\") {\n      selectedItem = items.filter(item => {\n        const itemSize = item.size;\n        const dist = item.pos + itemSize - pos;\n        const dist2 = dist - itemSize;\n\n        return dist <= 0\n          || (dist2 < 0 && isIntersection(dist2, dist, \"start\", intersection))\n          || (dist2 <= 0 && (!itemSize || Math.abs(dist2) / itemSize >= hitTest));\n      }).reverse()[0] || startVirtualItem;\n    } else if (target === \"next\") {\n      selectedItem = items.filter(item => {\n        const itemSize = item.size;\n        const dist = item.pos - endPos;\n        const dist2 = dist + itemSize;\n\n        return dist >= 0\n          || (dist2 > 0 && isIntersection(dist, dist2, \"end\", intersection))\n          || (dist2 >= 0 && (!itemSize || Math.abs(dist2) / itemSize >= hitTest));\n      })[0] || endVirtualItem;\n    } else {\n      return this._getItem(target);\n    }\n    if (sibling && selectedItem) {\n      const selectedIndex = items.indexOf(selectedItem);\n\n      if (selectedIndex > -1) {\n        selectedItem = items[selectedIndex + sibling];\n      }\n    }\n    return selectedItem || null;\n  }\n  /**\n   * Scrolls an element or an item in that direction into the view.\n   * @ko 엘리먼트나 해당 방향에 있는 아이템을 뷰안으로 스크롤을 한다.\n   * @see {@link /docs/examples/Methods target's example} page for detailed information\n   * @param - direction of the element. \"start\" and \"end\" find inside. \"prev\" and \"next\" find outside. <ko>엘리먼트의 방향. \"start\", \"end\"는 안쪽으로 찾는다. \"prev\", \"next\"는 바깥쪽으로 찾는다.</ko>\n   * @param - Options for the `scrollIntoView` method. <ko>`scrollIntoView` 메서드의 옵션</ko>\n   * @example\n   * <p align=\"center\">\n   *  <img src=\"https://naver.github.io/egjs-conveyer/img/scrollIntoView1.png\" height=\"200\" />\n   * </p>\n   * <p align=\"center\">\n   *   <img src=\"https://naver.github.io/egjs-conveyer/img/scrollIntoView2.png\" height=\"210\" />\n   * </p>\n   */\n  public scrollIntoView(target: HTMLElement | \"start\" | \"end\" | \"prev\" | \"next\", options: ScrollIntoViewOptions = {}) {\n    let item = this.findItem(target, options);\n\n    if (!item) {\n      return;\n    }\n    const duration = options.duration || 0;\n    let nextScrollPos = this._getNextScrollPos(item, options);\n\n    if (isString(target) && options.excludeStand && nextScrollPos === this._pos) {\n      const selectedIndex = this._items.indexOf(item);\n\n      if (selectedIndex === -1) {\n        return;\n      }\n      const sibling = target === \"start\" || target === \"prev\" ? -1 : 1;\n      item = this._items[selectedIndex + sibling];\n\n      if (!item) {\n        return;\n      }\n      nextScrollPos = this._getNextScrollPos(item, options);\n    }\n\n    this.scrollBy(nextScrollPos - this._pos, duration);\n  }\n  /**\n   * Scrolls by the given position amount.\n   * @ko 주어진 위치 양만큼 스크롤한다.\n   * @param - Amount of position to scroll by. <ko>스크롤할 위치의 양.</ko>\n   * @param - Duration to scroll by that position. <ko>해당 위치만큼 스크롤하는 시간</ko>\n   */\n  public scrollBy(pos: number, duration = 0) {\n    this._createAnimationParam(pos);\n    this._axes!.setBy({ scroll: -pos }, duration);\n  }\n  /**\n   * Scroll to the given position.\n   * @ko 주어진 위치로 스크롤한다.\n   * @param - Amount of position to scroll to. <ko>스크롤할 위치의 양.</ko>\n   * @param - Duration to scroll to that position. <ko>해당 위치로 스크롤하는 시간</ko>\n   */\n  public scrollTo(pos: number, duration = 0) {\n    this.scrollBy(pos - this._pos, duration);\n  }\n  /**\n   * Set the items directly to the Conveyer.\n   * @ko Conveyer에 아이템들을 직접 설정한다.\n   * @param - Items to set on Conveyer <ko>Conveyer에 설정할 아이템들</ko>\n   */\n  public setItems(items: ConveyerItem[]) {\n    this._items = items;\n  }\n  /**\n   * Update the position and size information of items.\n   * @ko 아이템들의 포지션, 사이즈 정보를 업데이트 한다.\n   */\n  public updateItems() {\n    const scrollAreaElement = this._scrollAreaElement;\n    const itemSelector = this._options.itemSelector;\n    const resizeObserver = this._resizeObserver;\n    const prevItemElements = this._items.map(item => item.element!);\n\n    const itemElements = [].slice.call(\n      itemSelector ? scrollAreaElement.querySelectorAll(itemSelector) : scrollAreaElement.children,\n    );\n    this.setItems(itemElements.map((el) => this._getItem(el)));\n\n    if (resizeObserver) {\n      const changed = diff(prevItemElements, itemElements);\n      const removed = changed.removed;\n      const added = changed.added;\n\n      removed.forEach((index) => resizeObserver.unobserve(changed.prevList[index]));\n      added.forEach((index) => resizeObserver.observe(changed.list[index]));\n    }\n\n  }\n  /**\n   * Update container size and scroll size.\n   * @ko 컨테이너의 크기, 스크롤 사이즈를 업데이트 한다.\n   */\n  public updateContainer() {\n    const scrollAreaElement = this._scrollAreaElement;\n    const horizontal = this._options.horizontal;\n\n    const size = horizontal ? scrollAreaElement.clientWidth : scrollAreaElement.clientHeight;\n    let scrollSize = horizontal ? scrollAreaElement.scrollWidth : scrollAreaElement.scrollHeight;\n\n    // check decimal point\n    if (IS_IE && scrollSize === size + 1) {\n      const style = getComputedStyle(scrollAreaElement);\n      const boxSizing = style.boxSizing;\n      const borderSize = horizontal\n        ? (parseFloat(style.borderLeftWidth) || 0) + (parseFloat(style.borderRightWidth) || 0)\n        : (parseFloat(style.borderTopWidth) || 0) + (parseFloat(style.borderBottomWidth) || 0);\n      const cssSize = parseFloat(horizontal ? style.width : style.height) || 0;\n      const contentSize = cssSize - (boxSizing === \"border-box\" ? borderSize : 0);\n\n      // 0 < 0.5 && 0.5 < 1\n      if (size < contentSize && contentSize < size + 1) {\n        scrollSize = size;\n      }\n    }\n    this._size = size;\n    this._scrollSize = scrollSize;\n    this._refreshScroll();\n    this._onScroll();\n  }\n  /**\n   * Updating containers and items.\n   * @ko 컨테이너와 아이템들을 업데이트 한다.\n   * @method\n   */\n  public update = () => {\n    this.updateItems();\n    this.updateContainer();\n  }\n  /**\n   * Enables PanInput and WheelInput operations in mouse case.\n   * @ko mouse 케이스에서 PanInput, WheelInput의 동작을 활성화한다.\n   */\n  public enableInput() {\n    this._panInput?.enable();\n    this._wheelInput?.enable();\n  }\n  /**\n   * Disables PanInput and WheelInput operations in mouse case.\n   * @ko mouse 케이스에서 PanInput, WheelInput의 동작을 비활성화한다.\n   */\n  public disableInput() {\n    this._panInput?.disable();\n    this._wheelInput?.disable();\n  }\n  /**\n   * If you use the autoInit option as false, you can initialize it directly through the init method.\n   * @ko autoInit 옵션을 false로 사용하는 경우 직접 init 메서드를 통해 초기화 할 수 있다.\n   */\n  public init() {\n    if (this._axes) {\n      return;\n    }\n\n    const scrollArea = this._scrollArea;\n    let el!: HTMLElement;\n\n    if (isString(scrollArea)) {\n      el = document.querySelector<HTMLElement>(scrollArea)!;\n    } else if (instanceOfElement(scrollArea)) {\n      el = scrollArea;\n    } else if (\"value\" in scrollArea || \"current\" in scrollArea) {\n      el = scrollArea.value! || scrollArea.current!;\n    }\n\n    if (!el) {\n      return;\n    }\n\n    this._scrollAreaElement = el;\n    let isDrag = false;\n    const scrollAreaElement = this._scrollAreaElement;\n    const options = this._options;\n    const axes = new Axes({\n      scroll: {\n        range: [-Infinity, Infinity],\n      },\n    }, {\n      deceleration: 0.005,\n      round: 1,\n      nested: options.nested,\n    }, {\n      scroll: 0,\n    });\n    let isHold = false;\n\n    axes.on({\n      \"hold\": e => {\n        isHold = true;\n        isDrag = false;\n        const nativeEvent = this._getNativeEvent(e);\n\n        if (!nativeEvent) {\n          return;\n        }\n        if (options.preventDefault) {\n          nativeEvent.preventDefault();\n        }\n      },\n      \"change\": e => {\n        const nativeEvent = this._getNativeEvent(e);\n        const animateParam = this._animateParam;\n        if (options.useSideWheel && this._isMixedWheel(nativeEvent)) {\n          return;\n        }\n        this._isWheelScroll = !!nativeEvent && nativeEvent.type === \"wheel\";\n        this._isDragScroll = !!nativeEvent && !this._isWheelScroll;\n        this._isAnimationScroll = !this._isWheelScroll && !isHold;\n        isDrag = true;\n        const scroll = e.delta.scroll;\n        if (!e.isTrusted && animateParam) {\n          animateParam.expectedPos -= scroll;\n          if (options.horizontal) {\n            scrollAreaElement.scrollLeft = animateParam.expectedPos + animateParam.offset;\n          } else {\n            scrollAreaElement.scrollTop = animateParam.expectedPos + animateParam.offset;\n          }\n        } else {\n          this._animateParam = null;\n          if (options.horizontal) {\n            scrollAreaElement.scrollLeft -= scroll;\n          } else {\n            scrollAreaElement.scrollTop -= scroll;\n          }\n        }\n        if (options.nested) {\n          this._checkNestedMove(nativeEvent);\n        }\n      },\n      \"release\": e => {\n        if (!isDrag) {\n          e.setTo({ ...e.depaPos }, 0);\n        }\n        isHold = false;\n        isDrag = false;\n      },\n    });\n\n    this._axes = axes;\n    if (options.useDrag) {\n      this._panInput = new PanInput(scrollAreaElement, {\n        preventClickOnDrag: options.preventClickOnDrag,\n        preventDefaultOnDrag: options.preventDefaultOnDrag,\n        inputType: [\"mouse\"],\n        touchAction: \"auto\",\n      });\n      axes.connect(options.horizontal ? [\"scroll\", \"\"] : [\"\", \"scroll\"], this._panInput);\n    }\n    if (options.useSideWheel) {\n      this._wheelInput = new WheelInput(scrollAreaElement, {\n        useNormalized: false,\n      });\n      axes.connect(options.horizontal ? [\"scroll\", \"\"] : [\"\", \"scroll\"], this._wheelInput);\n    }\n    if (options.useResizeObserver && window.ResizeObserver) {\n      this._resizeObserver = new ResizeObserver((entries: ResizeObserverEntry[]) => {\n        const items = this._items;\n        const length = items.length;\n        let index = length;\n\n        entries.forEach((entry: ResizeObserverEntry) => {\n          if (entry.target !== this._scrollAreaElement) {\n            for (let i = 0; i < length; i++) {\n              if (items[i].element === entry.target) {\n                index = Math.min(index, i);\n                break;\n              }\n            }\n          }\n        });\n\n        for (let i = index; i < length; i++) {\n          items[i] = this._getItem(items[i].element!);\n        }\n        this.updateContainer();\n      });\n\n    }\n\n    this.update();\n\n    this._resizeObserver?.observe(scrollAreaElement);\n    scrollAreaElement.addEventListener(\"scroll\", this._onScroll);\n    window.addEventListener(\"resize\", this.update);\n  }\n  /**\n   * Releases the instnace and events.\n   * @ko 인스턴스와 이벤트를 해제한다.\n   */\n  public destroy() {\n    this._axes?.destroy();\n    this.unsubscribe();\n    this._scrollAreaElement?.removeEventListener(\"scroll\", this._onScroll);\n    this._resizeObserver?.disconnect();\n\n    if (typeof window !== \"undefined\") {\n      window.removeEventListener(\"resize\", this.update);\n    }\n    this.off();\n    this._panInput = null;\n    this._wheelInput = null;\n    this._axes = null;\n    this._resizeObserver = null;\n  }\n  private _refreshScroll() {\n    const horizontal = this._options.horizontal;\n    const scrollAreaElement = this._scrollAreaElement;\n\n    this._pos = Math.min(\n      this._scrollSize - this._size,\n      horizontal ? scrollAreaElement.scrollLeft : scrollAreaElement.scrollTop,\n    );\n  }\n  private _getItem(element: HTMLElement): ConveyerItem {\n    const horizontal = this._options.horizontal;\n\n    return {\n      element,\n      pos: horizontal ? element.offsetLeft : element.offsetTop,\n      size: horizontal ? element.offsetWidth : element.offsetHeight,\n    };\n  }\n  private _getNativeEvent(e: OnHold | OnChange) {\n    return e?.inputEvent?.srcEvent ? e.inputEvent?.srcEvent : e?.inputEvent;\n  }\n  private _getNextScrollPos(item: ConveyerItem, options: ScrollIntoViewOptions) {\n    const size = this._size;\n    const scrollSize = this._scrollSize;\n    const align = options.align || \"start\";\n    const padding = options.offset || 0;\n    const itemPos = item!.pos;\n    const itemSize = item!.size;\n    let scrollPos = 0;\n\n    if (align === \"start\") {\n      scrollPos = itemPos - padding;\n    } else if (align === \"end\") {\n      scrollPos = itemPos + itemSize - size + padding;\n    } else if (align === \"center\") {\n      scrollPos = itemPos + itemSize / 2 - size / 2 + padding;\n    }\n    scrollPos = Math.max(0, Math.min(scrollPos, scrollSize - size));\n    return scrollPos;\n  }\n  private _isMixedWheel(nativeEvent: any) {\n    return !!nativeEvent && nativeEvent?.type === \"wheel\" && nativeEvent?.deltaX && nativeEvent?.deltaY;\n  }\n  private _checkNestedMove(nativeEvent: any) {\n    if (this.isReachStart || this.isReachEnd) {\n      nativeEvent.__childrenAxesAlreadyChanged = false;\n    }\n  }\n  private _onScroll = (e?: any) => {\n    if (e) {\n      this._debounceScroll();\n    }\n    this._refreshScroll();\n\n    const size = this._size;\n    const scrollSize = this._scrollSize;\n    const pos = this._pos;\n    const boundaryMargin = this._options.boundaryMargin ?? 0;\n\n    // enter start\n    if (pos <= boundaryMargin && this.isReachStart !== true) {\n      this._isReachStart = true;\n      /**\n       * This event is fired when scroll reach start.\n       * @ko 스크롤이 앞에 닿으면 발생하는 이벤트이다.\n       * @event Conveyer#reachStart\n       */\n      this.trigger(\"reachStart\");\n    } else if (pos > boundaryMargin && this.isReachStart !== false) {\n      this._isReachStart = false;\n      /**\n       * This event is fired when scroll leave start.\n       * @ko 스크롤이 앞에서 떠나면 발생하는 이벤트이다.\n       * @event Conveyer#leaveStart\n       */\n      this.trigger(\"leaveStart\");\n    }\n    // enter end\n    if (scrollSize - size - pos < 1 + boundaryMargin && this.isReachEnd !== true) {\n      this._isReachEnd = true;\n      /**\n       * This event is fired when scroll reach end.\n       * @ko 스크롤이 끝에 닿으면 발생하는 이벤트이다.\n       * @event Conveyer#reachEnd\n       */\n      this.trigger(\"reachEnd\");\n    } else if (!(scrollSize - size - pos < 1 + boundaryMargin) && this.isReachEnd !== false) {\n      this._isReachEnd = false;\n      /**\n       * This event is fired when scroll leave end.\n       * @ko 스크롤이 끝에서 떠나면 발생하는 이벤트이다.\n       * @event Conveyer#leaveEnd\n       */\n      this.trigger(\"leaveEnd\");\n    }\n  }\n  private _debounceScroll() {\n    if (!this._scrollTimer) {\n      /**\n       * This event is fired when begin scroll.\n       * @ko 스크롤이 시작하면 발생하는 이벤트이다.\n       * @event Conveyer#beginScroll\n       */\n      this.trigger(\"beginScroll\");\n    }\n    window.clearTimeout(this._scrollTimer);\n    this._scrollTimer = window.setTimeout(() => {\n      const isWheelScroll = this._isWheelScroll;\n      const isDragScroll = this._isDragScroll;\n      const isAnimationScroll = this._isAnimationScroll;\n      this._scrollTimer = 0;\n      /**\n       * This event is fired when finish scroll.\n       * @ko 스크롤이 끝나면 발생하는 이벤트이다.\n       * @event Conveyer#finishScroll\n       * @param {OnFinishScroll} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n       */\n      this.trigger(\"finishScroll\", {\n        isWheelScroll,\n        isDragScroll,\n        isAnimationScroll,\n        isTrusted: isWheelScroll || isDragScroll || !isAnimationScroll,\n      });\n\n      this._isWheelScroll = false;\n      this._isDragScroll = false;\n      this._isAnimationScroll = false;\n    }, this._options.scrollDebounce);\n  }\n\n  private _createAnimationParam(pos: number) {\n    // Save a decimal point before starting the animation\n    // and in case of animation (isTrusted: false), add the offset and scroll.\n    this._animateParam = {\n      expectedPos: this._pos,\n      offset: pos % 1,\n    };\n  }\n}\n\n\ninterface Conveyer extends ConveyerReactiveState, ReactiveSubscribe<ConveyerReactiveState> { }\n\nexport default Conveyer;\n","/**\n * egjs-conveyer\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport Conveyer, * as modules from \"./index\";\n\nfor (const name in modules) {\n  (Conveyer as any)[name] = (modules as any)[name];\n}\n\nexport default Conveyer;\n","/**\n * egjs-conveyer\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nexport const CONVEYER_METHODS = [\n  \"update\",\n  \"findElement\",\n  \"findItem\",\n  \"scrollBy\",\n  \"scrollTo\",\n  \"scrollIntoView\",\n  \"setItems\",\n  \"updateContainer\",\n  \"updateItems\",\n  \"init\",\n  \"enableInput\",\n  \"disableInput\",\n] as const;\n\nexport const CONVEYER_EVENTS = [\n  \"reachStart\",\n  \"reachEnd\",\n  \"leaveStart\",\n  \"leaveEnd\",\n  \"beginScroll\",\n  \"finishScroll\",\n] as const;\n\n","/**\n * egjs-conveyer\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nimport Conveyer from \"./Conveyer\";\nimport { CONVEYER_EVENTS, CONVEYER_METHODS } from \"./consts\";\nimport { ReactiveAdapter, Ref } from \"@cfcs/core\";\nimport { ConveyerEvents, ConveyerMethods, ConveyerOptions, ConveyerReactiveState } from \"./types\";\n\n\nexport interface ConveyerData {\n  container: Ref<HTMLElement>;\n  props: ConveyerOptions;\n}\n\nexport const REACTIVE_CONVEYER: ReactiveAdapter<\n  Conveyer,\n  ConveyerReactiveState,\n  keyof ConveyerMethods,\n  ConveyerData,\n  ConveyerEvents\n> = {\n  methods: CONVEYER_METHODS,\n  events: CONVEYER_EVENTS,\n  created(data) {\n    return new Conveyer(data.container, { ...data.props, autoInit: false });\n  },\n  init(instance, data) {\n    if (data.props.autoInit !== false) {\n      instance!.init();\n    }\n  },\n  on(instance, name, callback) {\n    instance.on(name, callback);\n  },\n  off(instance, name, callback) {\n    instance.off(name, callback);\n  },\n  destroy(instance) {\n    instance.destroy();\n  },\n};\n"],"names":["IS_IE","test","window","navigator","userAgent","toLowerCase","isString","val","isIntersection","pos1","pos2","target","intersection","size","Math","abs","name","__extends","scrollArea","options","_super","_this","updateItems","updateContainer","e","_debounceScroll","_refreshScroll","_size","scrollSize","_scrollSize","pos","_pos","boundaryMargin","_options","isReachStart","_isReachStart","trigger","isReachEnd","_isReachEnd","horizontal","useDrag","useSideWheel","autoInit","scrollDebounce","useResizeObserver","_scrollArea","init","__proto","direction","this","findItem","element","hitTest","items","_items","length","endPos","sibling","startVirtualItem","endVirtualItem","unshift","push","selectedItems","selectedItem","filter","item","itemSize","dist","dist2","reverse","_getItem","selectedIndex","indexOf","duration","nextScrollPos","_getNextScrollPos","excludeStand","scrollBy","_createAnimationParam","_axes","setBy","scroll","changed_1","scrollAreaElement","_scrollAreaElement","itemSelector","resizeObserver","_resizeObserver","prevItemElements","map","itemElements","slice","call","querySelectorAll","children","setItems","el","removed","diff","added","forEach","index","unobserve","prevList","observe","list","boxSizing","borderSize","clientWidth","clientHeight","scrollWidth","scrollHeight","style","getComputedStyle","parseFloat","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth","contentSize","width","height","_onScroll","_panInput","enable","_wheelInput","disable","isDrag","axes","isHold","document","querySelector","Element","Node","value","current","Axes","range","Infinity","deceleration","round","nested","on","hold","nativeEvent","_getNativeEvent","preventDefault","change","animateParam","_animateParam","_isMixedWheel","_isWheelScroll","type","_isDragScroll","_isAnimationScroll","delta","isTrusted","expectedPos","scrollLeft","offset","scrollTop","_checkNestedMove","release","setTo","depaPos","PanInput","preventClickOnDrag","preventDefaultOnDrag","inputType","touchAction","connect","WheelInput","useNormalized","ResizeObserver","entries","entry","i","min","update","addEventListener","destroy","unsubscribe","removeEventListener","disconnect","off","offsetLeft","offsetTop","offsetWidth","offsetHeight","inputEvent","srcEvent","align","padding","itemPos","scrollPos","max","deltaX","deltaY","__childrenAxesAlreadyChanged","_scrollTimer","clearTimeout","setTimeout","isWheelScroll","isDragScroll","isAnimationScroll","__decorate","Reactive","ReactiveSubscribe","Conveyer","Component","CONVEYER_METHODS","CONVEYER_EVENTS","methods","events","created","data","container","props","instance","callback","modules"],"mappings":"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"}